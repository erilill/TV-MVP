% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluation_functions.R
\name{evaluate_forecasts}
\alias{evaluate_forecasts}
\title{Evaluate Portfolio Forecasts Using Various Error Metrics}
\usage{
evaluate_forecasts(
  returns,
  forecasts,
  est_covariances,
  residual_covariances_pred,
  weights_est,
  window_eval,
  realized_covariances = NULL,
  realized_resid_covariances = NULL,
  true_weights = NULL,
  realized_sharpes = NULL
)
}
\arguments{
\item{returns}{A numeric matrix of actual asset returns with \eqn{T} rows (time periods)
and \eqn{p} columns (assets).}

\item{forecasts}{A numeric matrix of predicted means with \eqn{T} rows (time periods)
and \eqn{p} columns (assets).}

\item{est_covariances}{A list of length \eqn{T}, where each element is a \eqn{p \times p}
matrix of predicted covariances for each time period.}

\item{residual_covariances_pred}{A list of length \eqn{T}, where each element is a
\eqn{p \times p} matrix of predicted residual covariances for each time period.}

\item{weights_est}{A list of length \eqn{T}, where each element is a numeric vector
of portfolio weights of length \eqn{p} for each time period.}

\item{window_eval}{A numeric vector specifying the time indices to evaluate, e.g., \code{(W + 1):T}.}

\item{realized_covariances}{A list of length \eqn{T}, where each element is a
\eqn{p \times p} matrix of realized covariances for each time period. Defaults to \code{NULL}.}

\item{realized_resid_covariances}{A list of length \eqn{T}, where each element is a
\eqn{p \times p} matrix of realized residual covariances for each time period. Defaults to \code{NULL}.}

\item{true_weights}{A list of length \eqn{T}, where each element is a numeric vector
of true portfolio weights of length \eqn{p} for each time period. Defaults to \code{NULL}.}

\item{realized_sharpes}{A numeric vector of length \eqn{T} representing the realized
Sharpe Ratios for each time period. Defaults to \code{NULL}.}
}
\value{
A list containing the following error metrics:
\describe{
  \item{\code{risk_error}}{Numeric scalar. The average absolute difference between predicted
    and realized portfolio risks over the evaluation window.}
  \item{\code{weight_error}}{Numeric scalar. The average Euclidean distance between estimated
    and true portfolio weights over the evaluation window.}
  \item{\code{sharpe_error}}{Numeric scalar. The average absolute difference between
    predicted and realized Sharpe Ratios over the evaluation window.}
  \item{\code{covariance_error}}{Numeric scalar. The average Frobenius norm of the difference
    between predicted and realized covariance matrices over the evaluation window.}
  \item{\code{residual_cov_error}}{Numeric scalar. The average Frobenius norm of the difference
    between predicted and realized residual covariance matrices over the evaluation window.}
}
}
\description{
This function assesses the accuracy and reliability of portfolio forecasts by computing
multiple error metrics. It evaluates risk prediction accuracy, portfolio weight accuracy,
Sharpe ratio estimation accuracy, covariance matrix prediction accuracy, and residual
covariance matrix prediction accuracy.
}
\details{
The function computes the following error metrics over the specified evaluation window:
\enumerate{
  \item \strong{Risk Error:} For each portfolio, it calculates the absolute difference between the
    predicted risk (standard deviation) and the realized risk, then averages these differences.
  \item \strong{Weight Error:} For each portfolio, it computes the Euclidean distance between the
    estimated portfolio weights and the true portfolio weights, then averages these distances.
  \item \strong{Sharpe Ratio Error:} For each portfolio, it calculates the absolute difference
    between the predicted Sharpe Ratio (based on forecasted means and estimated covariances)
    and the realized Sharpe Ratio, then averages these differences.
  \item \strong{Covariance Error:} For each covariance matrix, it computes the Frobenius norm of
    the difference between the predicted and realized covariance matrices, then averages these norms.
  \item \strong{Residual Covariance Error:} Similarly, for each residual covariance matrix, it
    computes the Frobenius norm of the difference between the predicted and realized residual
    covariance matrices, then averages these norms.
}
}
\examples{
# Example parameters
T <- 100  # Number of time periods
p <- 50   # Number of assets

# Simulate actual returns
set.seed(123)
returns <- matrix(rnorm(T * p, mean=0.001, sd=0.02), nrow=T, ncol=p)

# Simulate forecasts (predicted means)
forecasts <- matrix(rnorm(T * p, mean=0.001, sd=0.015), nrow=T, ncol=p)

# Simulate estimated covariances
est_covariances <- lapply(1:T, function(t) {
  diag(runif(p, min=0.0001, max=0.002)) + matrix(runif(p^2, min=-0.0005, max=0.0005), nrow=p)
})

# Simulate predicted residual covariances
residual_covariances_pred <- lapply(1:T, function(t) {
  diag(runif(p, min=0.0001, max=0.002))
})

# Simulate estimated weights
weights_est <- lapply(1:T, function(t) {
  w <- runif(p)
  w / sum(w)
})

# Define evaluation window
window_eval <- 51:100

# Simulate realized covariances
realized_covariances <- lapply(1:T, function(t) {
  cov(returns[(max(1, t-10)):t, , drop=FALSE])
})

# Simulate realized residual covariances
realized_resid_covariances <- lapply(1:T, function(t) {
  diag(runif(p, min=0.0001, max=0.002))
})

# Simulate true weights
true_weights <- lapply(1:T, function(t) {
  w <- runif(p)
  w / sum(w)
})

# Simulate realized Sharpe Ratios
realized_sharpes <- runif(T, min=0.5, max=2.0)

# Evaluate forecasts
metrics <- evaluate_forecasts(
  returns = returns,
  forecasts = forecasts,
  est_covariances = est_covariances,
  residual_covariances_pred = residual_covariances_pred,
  weights_est = weights_est,
  window_eval = window_eval,
  realized_covariances = realized_covariances,
  realized_resid_covariances = realized_resid_covariances,
  true_weights = true_weights,
  realized_sharpes = realized_sharpes
)
print(metrics)

}
