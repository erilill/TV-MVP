% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pca_function.R
\name{compute_V_m}
\alias{compute_V_m}
\title{Compute Sum of Squared Residuals (V_m) for Portfolio Optimization}
\usage{
compute_V_m(returns, m, kernel_func, bandwidth)
}
\arguments{
\item{returns}{A numeric matrix of asset returns with \eqn{T} rows (time periods) and \eqn{p} columns (assets).}

\item{m}{An integer specifying the number of principal components (factors) to extract.}

\item{kernel_func}{A function representing the kernel used for weighting. Typically, an
Epanechnikov kernel or another boundary kernel function.}

\item{bandwidth}{A numeric value indicating the bandwidth parameter for the kernel function.}
}
\value{
A numeric scalar representing the sum of squared residuals (\code{V_m}) normalized by
the product of the number of assets and time periods (\eqn{p \times T}).
}
\description{
This function calculates the sum of squared residuals (\code{V_m}) for portfolio optimization
using a rolling window approach. For each time period, it applies boundary kernel weights,
performs Principal Component Analysis (PCA) to extract factors, computes residuals, and
aggregates the sum of squared residuals across all time periods.
}
\details{
The function performs the following steps for each time period \eqn{x = 1} to \eqn{T}:
\enumerate{
  \item Computes boundary kernel weights \eqn{w_x} using the specified \code{kernel_func} and \code{bandwidth}.
  \item Normalizes the weights so that they sum to 1.
  \item Applies the square root of the weights to the returns matrix.
  \item Performs PCA on the weighted returns to extract the first \code{m} principal components.
  \item Computes the fitted returns and residuals by subtracting the modeled returns from the actual returns.
  \item Aggregates the sum of squared residuals across all time periods.
}
Finally, \code{V_m} is computed by dividing the total sum of squared residuals by \eqn{p \times T}.
}
\examples{
# Load necessary library
library(ggplot2)

# Simulate data for 50 assets over 200 time periods
set.seed(123)
T <- 200
p <- 50
returns <- matrix(rnorm(T * p, mean = 0.001, sd = 0.02), ncol = p)

# Define an Epanechnikov kernel function (assuming it's defined elsewhere)
epanechnikov_kernel <- function(u) {
  ifelse(abs(u) <= 1, 0.75 * (1 - u^2), 0)
}

# Compute V_m for m = 5, bandwidth = 0.1
V_m <- compute_V_m(returns, m = 5, kernel_func = epanechnikov_kernel, bandwidth = 0.1)
print(V_m)

}
