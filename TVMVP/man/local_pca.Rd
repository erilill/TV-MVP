% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pca_function.R
\name{local_pca}
\alias{local_pca}
\title{Perform Local Principal Component Analysis (PCA)}
\usage{
local_pca(returns, r, bandwidth, m, kernel_func)
}
\arguments{
\item{returns}{A numeric matrix of asset returns with \eqn{T} rows (time periods) and \eqn{p} columns (assets).}

\item{r}{An integer specifying the current time period for which to perform PCA.}

\item{bandwidth}{A numeric value indicating the bandwidth parameter defining the window
around time period \code{r}.}

\item{m}{An integer specifying the number of principal components (factors) to extract.}

\item{kernel_func}{A function representing the kernel used for weighting. Typically, an
Epanechnikov kernel or another boundary kernel function.}
}
\value{
A list containing:
\describe{
  \item{\code{factors_full}}{Numeric matrix. Factor scores for the extracted principal components.}
  \item{\code{loadings_full}}{Numeric matrix. Loadings corresponding to the extracted principal components.}
}
}
\description{
This function conducts a local PCA on asset returns within a specified bandwidth around a
given time point. It extracts a defined number of principal components (factors) and
corresponding loadings for portfolio optimization.
}
\details{
The function performs the following steps:
\enumerate{
  \item Computes boundary kernel weights \eqn{w_r} for the current time period \code{r} using the
  specified \code{kernel_func} and \code{bandwidth}.
  \item Normalizes the weights so that they sum to 1.
  \item Applies the square root of the weights to the returns matrix to obtain weighted returns.
  \item Performs PCA on the weighted returns to extract the first \code{m} principal components.
  \item Normalizes the factor scores and extracts the corresponding loadings.
}
If the number of extracted principal components is less than 1, the function returns \code{NULL}.
}
\examples{
# Load necessary library
library(ggplot2)

# Simulate data for 50 assets over 200 time periods
set.seed(123)
T <- 200
p <- 50
returns <- matrix(rnorm(T * p, mean = 0.001, sd = 0.02), ncol = p)

# Define an Epanechnikov kernel function (assuming it's defined elsewhere)
epanechnikov_kernel <- function(u) {
  ifelse(abs(u) <= 1, 0.75 * (1 - u^2), 0)
}

# Perform local PCA for time period r = 100 with bandwidth = 10 and m = 5 factors
local_pca_result <- local_pca(returns, r = 100, bandwidth = 10, m = 5, kernel_func = epanechnikov_kernel)
print(local_pca_result$factors_full)
print(local_pca_result$loadings_full)

}
