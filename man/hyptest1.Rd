% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hypothesis_testing.R
\name{hyptest1}
\alias{hyptest1}
\title{Perform Hypothesis Test for Time-Varying Covariance Matrix}
\usage{
hyptest1(returns, m, B = 199, kernel_func = epanechnikov_kernel)
}
\arguments{
\item{kernel_func}{A function representing the kernel used for weighting. Typically, an
Epanechnikov kernel or another boundary kernel function. Defaults to \code{epanechnikov_kernel}.}

\item{local_factors}{A list where each element is a numeric matrix representing the
local factor scores for a specific time period. Each matrix should have \eqn{m} columns
(factors) and as many rows as time periods.}

\item{global_factors}{A numeric matrix of global factor scores with \eqn{T} rows
(time periods) and \eqn{m} columns (factors).}

\item{local_loadings}{A list where each element is a numeric matrix representing the
local factor loadings for a specific time period. Each matrix should have \eqn{p}
rows (assets) and \eqn{m} columns (factors).}

\item{global_loadings}{A numeric matrix of global factor loadings with \eqn{p} rows
(assets) and \eqn{m} columns (factors).}

\item{residuals}{A numeric matrix of residuals with \eqn{T} rows (time periods) and \eqn{p} columns (assets).}
}
\value{
A numeric scalar \eqn{J_{pT}} representing the computed test statistic.
}
\description{
This function conducts a hypothesis test to determine whether the covariance matrix of
asset returns is time-varying. It computes relevant test statistics and outputs the
test result based on the \eqn{J_{pT}} statistic.
}
\details{
The function performs the following steps:
\enumerate{
  \item Computes the factor covariance matrix by aggregating the local factors across all time periods.
  \item Determines the optimal bandwidth parameter \code{h} using Silverman's rule of thumb via the \code{silverman} function.
  \item Identifies the number of factors \eqn{m} based on the dimensionality of the local factors.
  \item Computes the \code{M_hat} statistic using \code{compute_M_hat}.
  \item Computes the \code{B_pT} statistic using \code{compute_B_pT}.
  \item Computes the \code{V_pT} statistic using \code{compute_V_pT}.
  \item Calculates the \code{J_pT} statistic using \code{compute_J_pT}.
  \item Outputs a message indicating whether there is evidence that the covariance is time-varying based on the \eqn{J_{pT}} value.
}

The hypothesis test follows:
\itemize{
  \item \strong{Null Hypothesis (\eqn{H_0}):} Covariance matrix is time-invariant.
  \item \strong{Alternative Hypothesis (\eqn{H_1}):} Covariance matrix is time-varying.
}

The test uses the standard normal critical value of 1.96 at the 5\% significance level.
}
\examples{
# Example parameters
T <- 100  # Number of time periods
p <- 50   # Number of assets
m <- 3    # Number of factors

# Simulate local factors and loadings
local_factors <- lapply(1:T, function(t) matrix(rnorm(m), nrow=1))
local_loadings <- lapply(1:T, function(t) matrix(runif(p * m), nrow=p, ncol=m))

# Simulate global factors and loadings
global_factors <- matrix(rnorm(T * m), nrow=T, ncol=m)
global_loadings <- matrix(runif(p * m), nrow=p, ncol=m)

# Simulate residuals
residuals <- matrix(rnorm(T * p, mean=0, sd=0.01), nrow=T, ncol=p)

# Define an Epanechnikov kernel function (assuming it's defined elsewhere)
epanechnikov_kernel <- function(u) {
  ifelse(abs(u) <= 1, 0.75 * (1 - u^2), 0)
}

# Perform hypothesis test
J_pT_value <- hyptest1(local_factors, global_factors, local_loadings, global_loadings,
                       residuals, kernel_func = epanechnikov_kernel)
print(J_pT_value)

}
